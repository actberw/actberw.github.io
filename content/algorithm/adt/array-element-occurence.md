Title: 数组元素出现次数问题
Tags: algorithm, data structure, array 
Date: 2014-06-11 23:00:00

### 唯一出现两次的数
>假设你有一个用1001个整数组成的数组，这些整数是任意排列的，但是你知道所有的整数都在1到1000(包括1000)之间。此外，除一个数字出现两次外，其他所有数字只出现一次。假设你只能对这个数组做一次处理，用一种算法找出重复的那个数字。如果你在运算中使用了辅助的存储方式，那么你能找到不用这种方式的算法吗?

已知1001个整数组成的数组只有一个数字出现了两次，且整数都在1到1000之间，所以可推得数组里面包含了1到1000之间的所有数字为[1,2,3……1000]和一个出现两次的x为1到1000中的任一个数字。这样就可以计算原数组里的所有数字之和S1和等差数列[1,2,3……1000]的和S2，再计算S1与S2之差，该差就是原数组中出现两次的数字x。时间复杂度是固定的O(n)。

    int func(const int a[]) {
        int s1 = 0, s2;
        s2 = 1001*1000/2;
        for(int i = 0; i<1001; i++) {
            s1+=a[i];
        }
        return s1-s2;
    }

### 数组中出现次数超过一半的数字 
>组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1。如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。

    int find_num(int *array, int n) {
        int num, count, i;
        if (array == NULL || n <= 0) return 0;

        num = array[0];
        count = 1 
        for (i = 1; i < n; i++) {
            if (count == 0) {
                num = array[i];
                count = 1;
            } else {
                if (array[i] == num) count++;
                else count--;
            }
        }

        return count ? num : 0; // count == 0 输入数组无效
    }

refer:

- [http://zhedahht.blog.163.com/blog/static/25411174201085114733349/](http://zhedahht.blog.163.com/blog/static/25411174201085114733349/)
